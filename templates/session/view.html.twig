{% extends 'base.html.twig' %}

{% block title %}{{ session.title }} - Documentation Collaborative{% endblock %}

{% block body %}
<div class="flex h-screen"
     id="session-container"
     data-session-id="{{ session.id }}"
     data-participant-id="{{ participant.id }}">

    <!-- Sidebar - Navigation des documents -->
    <aside class="w-64 bg-white border-r border-gray-200 flex flex-col">
        {% include 'session/_sidebar.html.twig' %}
    </aside>

    <!-- Zone principale -->
    <main class="flex-1 flex flex-col overflow-hidden">
        <!-- Header -->
        <header class="bg-white border-b border-gray-200 px-6 py-3" id="session-header">
            {% include 'session/_header.html.twig' %}
        </header>

        <!-- Contenu du document -->
        <div class="flex-1 overflow-auto p-6" id="document-content">
            {% if currentDocument %}
                {% include 'document/_view.html.twig' with {document: currentDocument} %}
            {% else %}
                {% include 'session/_welcome.html.twig' %}
            {% endif %}
        </div>
    </main>

    <!-- Panel annotations -->
    <aside class="w-80 bg-white border-l border-gray-200 flex flex-col" id="annotations-panel">
        {% include 'annotation/_panel.html.twig' %}
    </aside>
</div>
{% endblock %}

{% block javascripts %}
{{ parent() }}
<script>
    const sessionId = '{{ session.id }}';
    const participantId = '{{ participant.id }}';
    const mercureUrl = '{{ mercure_url }}';

    // Start heartbeat
    startHeartbeat(sessionId, participantId);

    // Connect to Mercure SSE for real-time updates
    const topics = [
        `/sessions/${sessionId}`,
        `/sessions/${sessionId}/presence`,
        `/sessions/${sessionId}/documents`,
        `/sessions/${sessionId}/annotations`,
        `/sessions/${sessionId}/decisions`
    ];

    const url = new URL(mercureUrl);
    topics.forEach(topic => url.searchParams.append('topic', topic));

    const eventSource = new EventSource(url, { withCredentials: false });

    // Helper function to refresh sidebar document tree
    function refreshDocumentTree() {
        htmx.ajax('GET', `/session/${sessionId}/sidebar`, {
            target: '#document-tree',
            swap: 'innerHTML'
        }).catch(e => console.error('Failed to refresh document tree:', e));
    }

    // Helper function to refresh current document content
    function refreshCurrentDocument(docId, docSlug) {
        const currentDocId = document.body.dataset.currentDocumentId;
        if (currentDocId && docId === currentDocId && docSlug) {
            htmx.ajax('GET', `/session/${sessionId}/document/${docSlug}`, {
                target: '#document-content',
                swap: 'innerHTML'
            }).catch(e => console.error('Failed to refresh document:', e));
        }
    }

    // Helper function to refresh annotations panel
    function refreshAnnotations(docId) {
        const annotationsPanel = document.getElementById('annotations-list');
        if (annotationsPanel) {
            const currentDocId = document.body.dataset.currentDocumentId;
            if (!currentDocId || docId === currentDocId) {
                htmx.ajax('GET', `/session/${sessionId}/annotations?document_id=${docId || ''}`, {
                    target: '#annotations-list',
                    swap: 'innerHTML'
                }).catch(e => console.error('Failed to refresh annotations:', e));
            }
        }
    }

    // Handle SSE event (named events use addEventListener, not onmessage)
    function handleSSEEvent(eventType, handler) {
        eventSource.addEventListener(eventType, function(event) {
            try {
                const message = JSON.parse(event.data);
                handler(message.data);
            } catch (e) {
                console.error('SSE parse error for', eventType, ':', e);
            }
        });
    }

    // Presence updates
    handleSSEEvent('presence.update', (data) => {
        updatePresence(data.participants);
    });

    // Document events
    handleSSEEvent('document.created', (data) => {
        refreshDocumentTree();
        // Remove "Aucun document" message if present
        const emptyMsg = document.getElementById('empty-docs-message');
        if (emptyMsg) emptyMsg.remove();
    });

    handleSSEEvent('document.updated', (data) => {
        refreshDocumentTree();
        refreshCurrentDocument(data.id, data.slug);
    });

    handleSSEEvent('document.deleted', (data) => {
        refreshDocumentTree();
        // If viewing deleted document, show welcome screen
        const currentDocId = document.body.dataset.currentDocumentId;
        if (currentDocId && data.id === currentDocId) {
            htmx.ajax('GET', `/session/${sessionId}`, {
                target: '#document-content',
                swap: 'innerHTML',
                select: '#document-content'
            });
        }
    });

    // Annotation events
    handleSSEEvent('annotation.created', (data) => {
        refreshAnnotations(data.document_id);
    });

    handleSSEEvent('annotation.updated', (data) => {
        refreshAnnotations(data.document_id);
    });

    handleSSEEvent('annotation.resolved', (data) => {
        refreshAnnotations(data.document_id);
    });

    // Decision events - refresh decisions list for current document
    function refreshDecisions(documentId) {
        const currentDocId = document.body.dataset.currentDocumentId;
        const decisionsContainer = document.getElementById('decisions-container');
        const decisionsList = document.getElementById('decisions-list');

        // Only refresh if viewing the same document or if documentId matches
        if (decisionsContainer && (documentId === currentDocId || !documentId)) {
            // Show container if hidden
            decisionsContainer.classList.remove('hidden');

            htmx.ajax('GET', `/session/${sessionId}/decisions?document_id=${currentDocId || ''}`, {
                target: '#decisions-list',
                swap: 'outerHTML'
            }).catch(e => console.error('Failed to refresh decisions:', e));
        }
    }

    handleSSEEvent('decision.created', (data) => {
        refreshDecisions(data.document_id);
    });

    handleSSEEvent('decision.updated', (data) => {
        refreshDecisions(data.document_id);
    });

    handleSSEEvent('decision.deleted', (data) => {
        refreshDecisions(data.document_id);
    });

    handleSSEEvent('decision.status_changed', (data) => {
        refreshDecisions(data.linked_document_id);
    });

    handleSSEEvent('vote.received', (data) => {
        refreshDecisions(null); // Refresh all since vote doesn't include document_id
    });

    // Session status change
    handleSSEEvent('session.status_changed', (data) => {
        // Reload the page to update status indicators
        window.location.reload();
    });

    // Fallback for unnamed events (shouldn't happen with our Mercure setup)
    eventSource.onmessage = function(event) {
        // Ignored - all events should be named
    };

    eventSource.onerror = function(err) {
        console.error('SSE connection error:', err);
    };

    function updatePresence(participants) {
        const container = document.getElementById('presence-indicator');
        const countEl = document.getElementById('presence-count');
        if (!container) return;

        let html = '';
        participants.forEach(p => {
            html += `
                <div class="relative group" title="${p.pseudo}">
                    <span class="w-8 h-8 rounded-full flex items-center justify-center text-white text-sm font-medium shadow-sm border-2 border-white"
                          style="background-color: ${p.color}">
                        ${p.pseudo.charAt(0).toUpperCase()}
                    </span>
                    <div class="absolute hidden group-hover:block top-full mt-1 left-1/2 -translate-x-1/2 bg-gray-900 text-white text-xs rounded py-1 px-2 whitespace-nowrap z-20">
                        ${p.pseudo}
                    </div>
                </div>
            `;
        });
        container.innerHTML = html;

        if (countEl) {
            countEl.textContent = participants.length + ' connectÃ©(s)';
        }
    }

    // Cleanup on page leave
    window.addEventListener('beforeunload', () => {
        eventSource.close();
    });
</script>
{% endblock %}
